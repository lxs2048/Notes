{
    "uniqueId": "生成唯一ID。 如果提供了 prefix ，会被添加到ID前缀上。",
    "toPath": "转化 value 为属性路径的数组 。",
    "times": "调用 iteratee n 次，每次调用返回的结果存入到数组中。 iteratee 调用入1个参数： (index)。",
    "stubTrue": "这个方法返回 true。",
    "stubString": "这个方法返回一个空字符串。",
    "stubObject": "这个方法返回一个空对象.",
    "stubFalse": "这个方法返回 false.",
    "stubArray": "这个方法返回一个新的空数组。",
    "runInContext": "创建一个给定context上下文对象的原始的 lodash 函数。",
    "rangeRight": "这个方法类似_.range ， 除了它是降序生成值的。",
    "range": "创建一个包含从 start 到 end，但不包含 end 本身范围数字的数组。 如果 start 是负数，而 end 或 step 没有指定，那么 step 从 -1 为开始。 如果 end 没有指定，start 设置为 0。 如果 end 小于 start ，会创建一个空数组，除非指定了 step。注意:: JavaScript 遵循 IEEE-754 标准处理无法预料的浮点数结果。",
    "propertyOf": "_.property的反相版本。 这个方法创建的函数返回给定 path 在object上的值。",
    "property": "创建一个返回给定对象的 path 的值的函数。",
    "overSome": "创建一个函数，传入提供的参数的函数并调用 predicates 判断是否 存在 有真值。",
    "overEvery": "建一个函数，传入提供的参数的函数并调用 predicates 判断是否 全部 都为真值。",
    "over": "创建一个函数，传入提供的参数的函数并调用 iteratees 返回结果。",
    "nthArg": "创建一个函数，这个函数返回第 n 个参数。如果 n为负数，则返回从结尾开始的第n个参数。",
    "noop": "这个方法返回 undefined。",
    "noConflict": "释放 _ 变量为原来的值，并返回一个 lodash 的引用。",
    "mixin": "添加来源对象自身的所有可枚举函数属性到目标对象。 如果 object 是个函数，那么函数方法将被添加到原型链上。注意: 使用_.runInContext 来创建原始的 lodash 函数来避免修改造成的冲突。",
    "methodOf": "_.method的反向版。 这个创建一个函数调用给定 object 的 path 上的方法， 任何附加的参数都会传入这个调用函数中。",
    "method": "创建一个调用给定对象 path 上的函数。 任何附加的参数都会传入这个调用函数中。",
    "matchesProperty": "创建一个深比较的方法来比较给定对象的 path 的值是否是 srcValue 。 如果是返回 true ，否则返回 false 。注意: 这个方法支持以_.isEqual 的方式比较相同的值。",
    "matches": "创建一个深比较的方法来比较给定的对象和 source 对象。 如果给定的对象拥有相同的属性值返回 true，否则返回 false。注意: 创建的函数相当于_.isMatch应用 source 。 部分比较匹配空数组和空对象源值，分别针对任何数组或对象的价值。见_.isEqual支持的价值比较的列表。",
    "iteratee": "创建一个函数，通过创建函数的参数调用 func 函数。 如果 func 是一个属性名，传入包含这个属性名的对象，回调返回对应属性名的值。 如果 func 是一个对象，传入的元素有相同的对象属性，回调返回 true 。 其他情况返回 false 。",
    "identity": "这个方法返回首个提供的参数。",
    "flowRight": "这个方法类似_.flow，除了它调用函数的顺序是从右往左的。",
    "flow": "创建一个函数。 返回的结果是调用提供函数的结果，this 会绑定到创建函数。 每一个连续调用，传入的参数都是前一个函数返回的结果。",
    "defaultTo": "检查value，以确定一个默认值是否应被返回。如果value为NaN, null, 或者 undefined，那么返回defaultValue默认值。",
    "constant": "创建一个返回 value 的函数。",
    "conforms": "创建一个函数。 这个函数会 调用 source 的属性名对应的 predicate 与传入对象相对应属性名的值进行断言处理。 如果都符合返回 true ，否则返回 false 。注意: 当source为偏应用时，这种方法等价于_.conformsTo。（注：关于偏应用大家可以自己到google上搜索一下）。",
    "cond": "创建了一个函数，这个函数会迭代pairs，并调用最先返回真值对应的函数。该断言函数对绑定 this 及传入创建函数的参数。",
    "bindAll": "绑定一个对象的方法到对象本身，覆盖现有的方法。注意: 这个方法不会设置绑定函数的 \"length\" 属性。",
    "attempt": "尝试调用func，返回结果 或者 捕捉错误对象。任何附加的参数都会在调用时传给func。",
    "words": "拆分字符串string中的词为数组 。",
    "upperFirst": "转换字符串string的首字母为大写。",
    "upperCase": "转换字符串string为 空格 分隔的大写单词。",
    "unescape": "_.escape的反向版。 这个方法转换string字符串中的 HTML 实体 &amp;, &lt;, &gt;, &quot;, &#39;, 和 &#96; 为对应的字符。 注意: 不会转换其他的 HTML 实体，需要转换可以使用类似 he 的第三方库。",
    "truncate": "截断string字符串，如果字符串超出了限定的最大值。 被截断的字符串后面会以 omission 代替，omission 默认是 \"...\"。",
    "trimStart": "从string字符串中移除前面的 空格 或 指定的字符。",
    "trimEnd": "从string字符串中移除后面的 空格 或 指定的字符。",
    "trim": "从string字符串中移除前面和后面的 空格 或 指定的字符。",
    "toUpper": "转换整个string字符串的字符为大写，类似String#toUpperCase.",
    "toLower": "转换整个string字符串的字符为小写，类似String#toLowerCase。",
    "template": "创建一个预编译模板方法，可以插入数据到模板中 \"interpolate\" 分隔符相应的位置。 HTML会在 \"escape\" 分隔符中转换为相应实体。 在 \"evaluate\" 分隔符中允许执行JavaScript代码。 在模板中可以自由访问变量。 如果设置了选项对象，则会优先覆盖_.templateSettings 的值。注意: 在开发过程中，构建_.template可以使用sourceURLs， 便于调试。 了解更多预编译模板的信息查看lodash的自定义构建文档。 了解更多 Chrome 沙箱扩展的信息查看Chrome的扩展文档。",
    "startsWith": "检查字符串string是否以 target 开头。",
    "startCase": "转换 string 字符串为start case.",
    "split": "根据separator 拆分字符串string。注意: 这个方法基于String#split.",
    "snakeCase": "转换字符串string为snake case.",
    "replace": "替换string字符串中匹配的pattern为给定的replacement 。注意: 这个方法基于String#replace.",
    "repeat": "重复 N 次给定字符串。",
    "parseInt": "转换string字符串为指定基数的整数。 如果基数是 undefined 或者 0，则radix基数默认是10，如果string字符串是16进制，则radix基数为 16。注意: 这个方法与ES5 implementation 的 parseInt是一样的。",
    "padStart": "如果string字符串长度小于 length 则在左侧填充字符。 如果超出length长度则截断超出的部分。",
    "padEnd": "如果string字符串长度小于 length 则在右侧填充字符。 如果超出length长度则截断超出的部分。",
    "pad": "如果string字符串长度小于 length 则从左侧和右侧填充字符。 如果没法平均分配，则截断超出的长度。",
    "lowerFirst": "转换字符串string的首字母为小写。",
    "lowerCase": "转换字符串string以空格分开单词，并转换为小写。",
    "kebabCase": "转换字符串string为kebab case.",
    "escapeRegExp": "转义 RegExp 字符串中特殊的字符 \"^\", \"$\", \"\", \".\", \"*\", \"+\", \"?\", \"(\", \")\", \"[\", \"]\", \", \", 和 \"|\" in .",
    "escape": "转义string中的 \"&\", \"<\", \">\", '\"', \"'\", 和 \"`\" 字符为HTML实体字符。注意: 不会转义其他字符。如果需要，可以使用第三方库，例如he。 虽然 \">\" 是对称转义的，字符如 \">\" 和 \"/\" 没有特殊的意义，所以不需要在 HTML 转义。 除非它们是标签的一部分，或者是不带引号的属性值。 查看Mathias Bynens's article 的文章 (under \"semi-related fun fact\") 了解详情 。 在 IE < 9 中转义引号，因为会中断属性值或 HTML 注释，查看HTML5 Security Cheatsheet 的#59,#102,#108, 和#133, 以及#133 了解详情。 当解析 HTML 时，总应该在属性值上使用引号 以减少 XSS 的可能性。",
    "endsWith": "检查字符串string是否以给定的target字符串结尾。",
    "deburr": "转换字符串string中拉丁语-1补充字母 和拉丁语扩展字母-A 为基本的拉丁字母，并且去除组合变音标记。",
    "capitalize": "转换字符串string首字母为大写，剩下为小写。",
    "camelCase": "转换字符串string为驼峰写法。",
    "value": "执行链式队列并提取解链后的值。",
    "reverse": "反转array，使得第一个元素变为最后一个元素，第二个元素变为倒数第二个元素，依次类推。Note: 这个方法会改变原数组 array，基于Array#reverse.",
    "plant": "创建一个链式队列的拷贝，传入的 value 作为链式队列的值。",
    "next": "获得包装对象的下一个值，遵循iterator protocol。",
    "commit": "执行链式队列并返回结果。",
    "chain": "创建一个lodash包装实例，包装value以启用显式链模式。要解除链必须使用 _#value 方法。",
    "at": "创建一个数组，值来自 object 的paths路径相应的值。",
    "iterator]": "启用包装对象为 iterable。",
    "thru": "这个方法类似_.tap， 除了它返回 interceptor 的返回结果。该方法的目的是\"传递\" 值到一个方法链序列以取代中间结果。",
    "tap": "这个方法调用一个 interceptor 并返回 value。interceptor调用1个参数： (value)。 该方法的目的是 进入 方法链序列以便修改中间结果。",
    "/docs/lodash": "创建一个lodash对象，包装value后的对象启用隐式方法链。返回的数组、集合、方法相互之间能够链式调用。检索唯一值或返回原始值会自动解除链条并返回计算后的值，否则需要调用 _#value 方法解除链(即获得计算结果)。 显式链式调用，在任何情况下需要先用 _#value 解除链后，才能使用_.chain 开启。 链式方法是惰性计算的，直到隐式或者显式调用了 _#value 才会执行计算。 惰性计算接受几种支持 shortcut fusion 的方法， shortcut fusion 是一种通过合并链式 iteratee 调用从而大大降低迭代的次数以提高执行性能的方式。 部分链有资格 shortcut fusion，如果它至少有超过200个元素的数组和任何只接受一个参数的 iteratees。 触发的方式是任何一个 shortcut fusion 有了变化。 链式方法支持定制版本，只要 _#value 包含或者间接包含在版本中。 除了 lodash 的自身方法，包装后的对象还支持 Array 和 String 的方法。 支持 Array 的方法:concat, join, pop, push, shift, sort, splice, 和 unshift 支持 String 的方法:replace 和 split 支持 shortcut fusion 的方法:at, compact, drop, dropRight, dropWhile, filter, find,findLast, head, initial, last, map, reject, reverse, slice,tail, take, takeRight, takeRightWhile, takeWhile, 和 toArray 支持 链式调用 的方法:after, ary, assign, assignIn, assignInWith, assignWith, at,before, bind, bindAll, bindKey, castArray, chain, chunk,commit, compact, concat, conforms, constant, countBy, create,curry, debounce, defaults, defaultsDeep, defer, delay,difference, differenceBy, differenceWith, drop, dropRight,dropRightWhile, dropWhile, extend, extendWith, fill, filter,flatMap, flatMapDeep, flatMapDepth, flatten, flattenDeep,flattenDepth, flip, flow, flowRight, fromPairs, functions,functionsIn, groupBy, initial, intersection, intersectionBy,intersectionWith, invert, invertBy, invokeMap, iteratee, keyBy,keys, keysIn, map, mapKeys, mapValues, matches, matchesProperty,memoize, merge, mergeWith, method, methodOf, mixin, negate,nthArg, omit, omitBy, once, orderBy, over, overArgs,overEvery, overSome, partial, partialRight, partition, pick,pickBy, plant, property, propertyOf, pull, pullAll, pullAllBy,pullAllWith, pullAt, push, range, rangeRight, rearg, reject,remove, rest, reverse, sampleSize, set, setWith, shuffle,slice, sort, sortBy, splice, spread, tail, take, takeRight,takeRightWhile, takeWhile, tap, throttle, thru, toArray,toPairs, toPairsIn, toPath, toPlainObject, transform, unary,union, unionBy, unionWith, uniq, uniqBy, uniqWith, unset,unshift, unzip, unzipWith, update, updateWith, values,valuesIn, without, wrap, xor, xorBy, xorWith, zip,zipObject, zipObjectDeep, and zipWith 默认 不 支持 链式调用 的方法:add, attempt, camelCase, capitalize, ceil, clamp, clone,cloneDeep, cloneDeepWith, cloneWith, conformsTo, deburr,defaultTo, divide, each, eachRight, endsWith, eq, escape,escapeRegExp, every, find, findIndex, findKey, findLast,findLastIndex, findLastKey, first, floor, forEach, forEachRight,forIn, forInRight, forOwn, forOwnRight, get, gt, gte, has,hasIn, head, identity, includes, indexOf, inRange, invoke,isArguments, isArray, isArrayBuffer, isArrayLike, isArrayLikeObject,isBoolean, isBuffer, isDate, isElement, isEmpty, isEqual,isEqualWith, isError, isFinite, isFunction, isInteger, isLength,isMap, isMatch, isMatchWith, isNaN, isNative, isNil, isNull,isNumber, isObject, isObjectLike, isPlainObject, isRegExp,isSafeInteger, isSet, isString, isUndefined, isTypedArray,isWeakMap, isWeakSet, join, kebabCase, last, lastIndexOf,lowerCase, lowerFirst, lt, lte, max, maxBy, mean, meanBy,min, minBy, multiply, noConflict, noop, now, nth, pad,padEnd, padStart, parseInt, pop, random, reduce, reduceRight,repeat, result, round, runInContext, sample, shift, size,snakeCase, some, sortedIndex, sortedIndexBy, sortedLastIndex,sortedLastIndexBy, startCase, startsWith, stubArray, stubFalse,stubObject, stubString, stubTrue, subtract, sum, sumBy,template, times, toFinite, toInteger, toJSON, toLength,toLower, toNumber, toSafeInteger, toString, toUpper, trim,trimEnd, trimStart, truncate, unescape, uniqueId, upperCase,upperFirst, value, and words",
    "valuesIn": "创建 object 自身和继承的可枚举属性的值为数组注意: 注意: 非对象的值会强制转换为对象。",
    "values": "创建 object 自身可枚举属性的值为数组。注意: 注意: 非对象的值会强制转换为对象。",
    "updateWith": "该方法类似_.update，不同之处在于它接受customizer，调用来生成新的对象的path。如果customizer返回undefined，路径创建由该方法代替。customizer调用有三个参数：(nsValue, key, nsObject) 。Note: 这个方法会改变 object.",
    "update": "该方法类似_.set，除了接受updater以生成要设置的值。使用_.updateWith来自定义生成的新path。updater调用1个参数：(value)。Note: 这个方法会改变 object。",
    "unset": "移除object对象 path 路径上的属性。注意: 这个方法会改变源对象 object。",
    "transform": "_.reduce的替代方法;此方法将转换object对象为一个新的accumulator对象，结果来自iteratee处理自身可枚举的属性。 每次调用可能会改变 accumulator 对象。如果不提供accumulator，将使用与[[Prototype]]相同的新对象。iteratee调用4个参数：(accumulator, value, key, object)。如果返回 false，iteratee 会提前退出。",
    "toPairsIn": "创建一个object对象自身和继承的可枚举属性的键值对数组。这个数组可以通过_.fromPairs撤回。如果object 是 map 或 set，返回其条目。",
    "toPairs": "创建一个object对象自身可枚举属性的键值对数组。这个数组可以通过_.fromPairs撤回。如果object 是 map 或 set，返回其条目。",
    "setWith": "这个方法类似_.set，除了它接受一个 customizer，调用生成对象的 path。 如果 customizer 返回 undefined 将会有它的处理方法代替。 customizer 调用3个参数： (nsValue, key, nsObject)。注意: 这个方法会改变 object.",
    "set": "设置 object对象中对应 path 属性路径上的值，如果path不存在，则创建。 缺少的索引属性会创建为数组，而缺少的属性会创建为对象。 使用_.setWith 定制path创建。Note: 这个方法会改变 object。",
    "result": "这个方法类似_.get， 除了如果解析到的值是一个函数的话，就绑定 this 到这个函数并返回执行后的结果。",
    "pickBy": "创建一个对象，这个对象组成为从 object 中经 predicate 判断为真值的属性。 predicate调用2个参数：(value, key)。",
    "pick": "创建一个从 object 中选中的属性的对象。",
    "omitBy": "反向版_.pickBy；这个方法一个对象，这个对象忽略 predicate（断言函数）判断不是真值的属性后，object自身和继承的可枚举属性组成。predicate调用与2个参数：(value, key)。",
    "omit": "反向版_.pick; 这个方法一个对象，这个对象由忽略属性之外的object自身和继承的可枚举属性组成。（注：可以理解为删除object对象的属性）。",
    "mergeWith": "该方法类似_.merge，除了它接受一个 customizer，调用以产生目标对象和来源对象属性的合并值。如果customizer 返回 undefined，将会由合并处理方法代替。customizer调用与7个参数：(objValue, srcValue, key, object, source, stack)。Note: 这方法会改变对象 object.",
    "merge": "该方法类似_.assign， 除了它递归合并 sources 来源对象自身和继承的可枚举属性到 object 目标对象。如果目标值存在，被解析为undefined的sources 来源对象属性将被跳过。数组和普通对象会递归合并，其他对象和值会被直接分配覆盖。源对象从从左到右分配。后续的来源对象属性会覆盖之前分配的属性。Note: 这方法会改变对象 object.",
    "mapValues": "创建一个对象，这个对象的key与object对象相同，值是通过 iteratee 运行 object 中每个自身可枚举属性名字符串产生的。 iteratee调用三个参数： (value, key, object)。",
    "mapKeys": "反向版_.mapValues。 这个方法创建一个对象，对象的值与object相同，并且 key 是通过 iteratee 运行 object 中每个自身可枚举属性名字符串 产生的。iteratee调用三个参数： (value, key, object)。",
    "keysIn": "创建一个 object 自身 和 继承的可枚举属性名为数组。注意: 非对象的值会被强制转换为对象。",
    "keys": "创建一个 object 的自身可枚举属性名为数组。Note: 非对象的值会被强制转换为对象，查看ES spec 了解详情。",
    "invoke": "调用object对象path上的方法。",
    "invertBy": "这个方法类似_.invert，除了倒置对象 是 collection（集合）中的每个元素经过 iteratee（迭代函数） 处理后返回的结果。每个反转键相应反转的值是一个负责生成反转值key的数组。iteratee 会传入3个参数：(value) 。",
    "invert": "创建一个object键值倒置后的对象。 如果 object 有重复的值，后面的值会覆盖前面的值。",
    "hasIn": "检查 path 是否是object对象的直接或继承属性。",
    "has": "检查 path 是否是object对象的直接属性。",
    "get": "根据 object对象的path路径获取值。 如果解析 value 是 undefined 会以 defaultValue 取代。",
    "functionsIn": "创建一个函数属性名称的数组，函数属性名称来自object对象自身和继承的可枚举属性。",
    "functions": "创建一个函数属性名称的数组，函数属性名称来自object对象自身可枚举属性。",
    "forOwnRight": "这个方法类似_.forOwn。 除了它是反方向开始遍历object的。",
    "forOwn": "使用 iteratee 遍历自身的可枚举属性。 iteratee 会传入3个参数：(value, key, object)。 如果返回 false，iteratee 会提前退出遍历。",
    "forInRight": "这个方法类似_.forIn。 除了它是反方向开始遍历object的。",
    "forIn": "使用 iteratee 遍历对象的自身和继承的可枚举属性。 iteratee 会传入3个参数：(value, key, object)。 如果返回 false，iteratee 会提前退出遍历。",
    "findLastKey": "这个方法类似_.findKey。 不过它是反方向开始遍历的。",
    "findKey": "这个方法类似_.find 。 除了它返回最先被 predicate 判断为真值的元素 key，而不是元素本身。",
    "defaultsDeep": "这个方法类似_.defaults，除了它会递归分配默认属性。注意: 这方法会改变 object.",
    "defaults": "分配来源对象的可枚举属性到目标对象所有解析为 undefined 的属性上。 来源对象从左到右应用。 一旦设置了相同属性的值，后续的将被忽略掉。注意: 这方法会改变 object.",
    "create": "创建一个继承 prototype 的对象。 如果提供了 prototype，它的可枚举属性会被分配到创建的对象上。",
    "assignWith": "这个方法类似_.assign ， 除了它接受一个 customizer 决定如何分配值。 如果customizer返回 undefined 将会由分配处理方法代替。customizer 会传入5个参数： (objValue, srcValue, key, object, source)。Note: 这方法会改变 object.",
    "assignInWith": "这个方法类似_.assignIn， 除了它接受一个 customizer ，被调用以产生所分配的值。 如果 customizer 返回 undefined 将会由分配处理方法代替。 customizer 会传入5个参数： (objValue, srcValue, key, object, source)。Note: 这方法会改变 object。",
    "assignIn": "这个方法类似_.assign， 除了它会遍历并继承来源对象的属性。Note: 这方法会改变 object。",
    "assign": "分配来源对象的可枚举属性到目标对象上。 来源对象的应用规则是从左到右，随后的下一个对象的属性会覆盖上一个对象的属性。注意: 这方法会改变 object，参考自Object.assign.",
    "random": "产生一个包括 lower 与 upper 之间的数。 如果只提供一个参数返回一个0到提供数之间的数。 如果 floating 设为 true，或者 lower 或 upper 是浮点数，结果返回浮点数。注意: JavaScript 遵循 IEEE-754 标准处理无法预料的浮点数结果。",
    "inRange": "检查 n 是否在 start 与 end 之间，但不包括 end。 如果 end 没有指定，那么 start 设置为0。 如果 start 大于 end，那么参数会交换以便支持负范围。",
    "clamp": "返回限制在 lower 和 upper 之间的值。",
    "sumBy": "这个方法类似_.summin 除了它接受 iteratee 来调用 array中的每一个元素，来生成其值排序的标准。 iteratee 会调用1个参数: (value) 。",
    "sum": "计算 array 中值的总和",
    "subtract": "亮数相减。",
    "round": "根据 precision（精度） 四舍五入 number。",
    "multiply": "两个数相乘。",
    "minBy": "这个方法类似_.min 除了它接受 iteratee 来调用 array中的每一个元素，来生成其值排序的标准。 iteratee 会调用1个参数: (value) 。",
    "min": "计算 array 中的最小值。 如果 array 是 空的或者假值将会返回 undefined。",
    "meanBy": "这个方法类似_.mean， 除了它接受 iteratee 来调用 array中的每一个元素，来生成其值排序的标准。 iteratee 会调用1个参数: (value) 。",
    "mean": "计算 array 的平均值。",
    "maxBy": "这个方法类似_.max 除了它接受 iteratee 来调用 array中的每一个元素，来生成其值排序的标准。 iteratee 会调用1个参数: (value) 。",
    "max": "计算 array 中的最大值。 如果 array 是 空的或者假值将会返回 undefined。",
    "floor": "根据 precision（精度） 向下舍入 number。（注： precision（精度）可以理解为保留几位小数。）",
    "divide": "两个数相除。",
    "ceil": "根据 precision（精度） 向上舍入 number。（注： precision（精度）可以理解为保留几位小数。）",
    "add": "两个数相加。",
    "toString": "转换 value 为字符串。 null 和 undefined 将返回空字符串。-0 将被转换为字符串\"-0\"。",
    "toSafeInteger": "转换 value 为安全整数。 安全整数可以用于比较和准确的表示。",
    "toPlainObject": "转换 value 为普通对象。 包括继承的可枚举属性。",
    "toNumber": "转换 value 为一个数字。",
    "toLength": "转换 value 为用作类数组对象的长度整数。注意: 这个方法基于ToLength.",
    "toInteger": "转换 value 为一个整数。注意: 这个方法基于ToInteger.",
    "toFinite": "转换 value 为一个有限数字。",
    "toArray": "转换 value 为一个数组。",
    "lte": "检查 value 是否小于等于 other。",
    "lt": "检查 value 是否小于 other。",
    "isWeakSet": "检查 value 是否是 WeakSet 对象。",
    "isWeakMap": "检查 value 是否是 WeakMap 对象。",
    "isUndefined": "检查 value 是否是 undefined.",
    "isTypedArray": "检查 value 是否是TypedArray。",
    "isSymbol": "检查 value 是否是原始 Symbol 或者对象。",
    "isString": "检查 value 是否是原始字符串String或者对象。",
    "isSet": "检查 value 是否是一个Set对象。",
    "isSafeInteger": "检查 value 是否是一个安全整数。 一个安全整数应该是符合 IEEE-754 标准的非双精度浮点数。注意: 这个方法基于Number.isSafeInteger.",
    "isRegExp": "检查 value 是否为RegExp对象。",
    "isPlainObject": "检查 value 是否是普通对象。 也就是说该对象由 Object 构造函数创建，或者 [[Prototype]] 为 null 。",
    "isObjectLike": "检查 value 是否是 类对象。 如果一个值是类对象，那么它不应该是 null，而且 typeof 后的结果是 \"object\"。",
    "isObject": "检查 value 是否为 Object 的language type。 (例如： arrays, functions, objects, regexes,new Number(0), 以及 new String(''))",
    "isNumber": "检查 value 是否是原始Number数值型 或者 对象。注意: 要排除 Infinity, -Infinity, 以及 NaN 数值类型，用_.isFinite 方法。",
    "isNull": "检查 valuealue 是否是 null。",
    "isNil": "检查 value 是否是 null 或者 undefined。",
    "isNative": "检查 value 是否是一个原生函数。注意： 这种方法不能可靠地检测在core-js包中存在的本地函数，因为 core-js 规避这种检测。尽管有多个请求，core-js 维护者已经明确表态：任何试图修复检测将受阻。这样一来，我们别无选择，只能抛出一个错误。不幸的是，这也影响其他的包，比如依赖于 core-js的babel-polyfill。",
    "isNaN": "检查 value 是否是 NaN。注意: 这个方法基于Number.isNaN，和全局的isNaN 不同之处在于，全局的isNaN对 于 undefined 和其他非数字的值返回 true。",
    "isMatchWith": "这个方法类似_.isMatch。 除了它接受一个 customizer 定制比较的值。 如果 customizer 返回 undefined 将会比较处理方法代替。 customizer 会传入5个参数：(objValue, srcValue, index|key, object, source)。",
    "isMatch": "执行一个深度比较，来确定 object 是否含有和 source 完全相等的属性值。注意: 当source为偏应用时，这种方法等价于_.matches。（注：关于偏应用大家可以自己到google上搜索一下）。 偏应用比较匹配空数组和空对象source值分别针对任何数组或对象的价值。在_.isEqual中查看支持的值比较列表。",
    "isMap": "检查 value 是否为一个 Map 对象。",
    "isLength": "检查 value 是否为有效的类数组长度。注意: 这个函数基于ToLength.",
    "isInteger": "检查 value 是否为一个整数。注意: 这个方法基于Number.isInteger.",
    "isFunction": "检查 value 是否是 Function 对象。",
    "isFinite": "检查 value 是否是原始有限数值。 ** 注意:** 这个方法基于Number.isFinite.",
    "isError": "检查 value 是否是 Error, EvalError, RangeError, ReferenceError,SyntaxError, TypeError, 或者 URIError对象。",
    "isEqualWith": "这个方法类似_.isEqual。 除了它接受一个 customizer 用来定制比较值。 如果 customizer 返回 undefined 将会比较处理方法代替。 customizer 会传入6个参数：(objValue, othValue [, index|key, object, other, stack])",
    "isEqual": "执行深比较来确定两者的值是否相等。 **注意: **这个方法支持比较 arrays, array buffers, booleans, date objects, error objects, maps, numbers, Object objects, regexes, sets, strings, symbols, 以及 typed arrays. Object 对象值比较自身的属性，不包括继承的和可枚举的属性。 不支持函数和DOM节点比较。",
    "isEmpty": "检查 value 是否为一个空对象，集合，映射或者set。 判断的依据是除非是有枚举属性的对象，length 大于 0 的 arguments object, array, string 或类jquery选择器。 对象如果被认为为空，那么他们没有自己的可枚举属性的对象。 类数组值，比如arguments对象，array，buffer，string或者类jQuery集合的length 为 0，被认为是空。类似的，map（映射）和set 的size 为 0，被认为是空。",
    "isElement": "检查 value 是否是可能是 DOM 元素。",
    "isDate": "检查 value 是否是 Date 对象。",
    "isBuffer": "检查 value 是否是个 buffer。",
    "isBoolean": "检查 value 是否是原始 boolean 类型或者对象。",
    "isArrayLikeObject": "这个方法类似_.isArrayLike。除了它还检查value是否是个对象。",
    "isArrayLike": "检查 value 是否是类数组。 如果一个值被认为是类数组，那么它不是一个函数，并且value.length是个整数，大于等于 0，小于或等于 Number.MAX_SAFE_INTEGER。",
    "isArrayBuffer": "检查 value 是否是 ArrayBuffer 对象。",
    "isArray": "检查 value 是否是 Array 类对象。",
    "isArguments": "检查 value 是否是一个类 arguments 对象。",
    "gte": "检查 value是否大于或者等于 other。",
    "gt": "检查 value是否大于 other。",
    "eq": "执行SameValueZero 比较两者的值，来确定它们是否相等。",
    "conformsTo": "通过调用断言source的属性与 object 的相应属性值，检查 object是否符合 source。当source偏应用时，这种方法和_.conforms函数是等价的。注意: 当source为偏应用时，这种方法等价于_.conforms。（注：关于偏应用大家可以自己到google上搜索一下）。",
    "cloneWith": "这个方法类似_.clone，除了它接受一个 customizer 定制返回的克隆值。 如果 customizer 返回 undefined 将会使用拷贝方法代替处理。 customizer 调用4个参数： (value [, index|key, object, stack])。",
    "cloneDeepWith": "这个方法类似_.cloneWith，除了它会递归克隆 value。",
    "cloneDeep": "这个方法类似_.clone，除了它会递归拷贝 value。（注：也叫深拷贝）。",
    "clone": "创建一个 value 的浅拷贝。注意: 这个方法参考自structured clone algorithm 以及支持 arrays、array buffers、 booleans、 date objects、maps、 numbers， Object 对象, regexes, sets, strings, symbols, 以及 typed arrays。 arguments对象的可枚举属性会拷贝为普通对象。 一些不可拷贝的对象，例如error objects、functions, DOM nodes, 以及 WeakMaps 会返回空对象。",
    "castArray": "如果 value 不是数组, 那么强制转为数组。",
    "wrap": "创建一个函数。提供的 value 包装在 wrapper 函数的第一个参数里。 任何附加的参数都提供给 wrapper 函数。 被调用时 this 绑定在创建的函数上。",
    "unary": "创建一个最多接受一个参数的函数，忽略多余的参数。",
    "throttle": "创建一个节流函数，在 wait 秒内最多执行 func 一次的函数。 该函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。 可以提供一个 options 对象决定如何调用 func 方法， options.leading 与|或 options.trailing 决定 wait 前后如何触发。 func 会传入最后一次传入的参数给这个函数。 随后调用的函数返回是最后一次 func 调用的结果。注意: 如果 leading 和 trailing 都设定为 true 则 func 允许 trailing 方式调用的条件为: 在 wait 期间多次调用。 如果 wait 为 0 并且 leading 为 false, func调用将被推迟到下一个点，类似setTimeout为0的超时。 查看David Corbacho's article 了解_.throttle 与_.debounce 的区别。",
    "spread": "创建一个函数，调用func时，this绑定到创建的新函数，把参数作为数组传入，类似于Function#apply.Note: 这个方法基于spread operator.",
    "rest": "创建一个函数，调用func时，this绑定到创建的新函数，并且start之后的参数作为数组传入。Note: 这个方法基于rest parameter。",
    "rearg": "创建一个函数,调用func时，根据指定的 indexes 调整对应位置参数。其中第一个索引值是对应第一个参数，第二个索引值是作为第二个参数，依此类推。",
    "partialRight": "这个函数类似_.partial，除了预设参数被附加到接受参数的后面。 这个 _.partialRight.placeholder 的值，默认是以 _ 作为附加部分参数的占位符。注意: 这个方法不会设置 \"length\" 到函数上。",
    "partial": "创建一个函数。 该函数调用 func，并传入预设的 partials 参数。 这个方法类似_.bind，除了它不会绑定 this。 这个 _.partial.placeholder 的值，默认是以 _ 作为附加部分参数的占位符。注意: 这个方法不会设置 \"length\" 到函数上。",
    "overArgs": "创建一个函数，调用func时参数为相对应的transforms的返回值。",
    "once": "创建一个只能调用 func 一次的函数。 重复调用返回第一次调用的结果。 func 调用时， this 绑定到创建的函数，并传入对应参数。",
    "negate": "创建一个针对断言函数 func 结果取反的函数。 func 断言函数被调用的时候，this 绑定到创建的函数，并传入对应参数。",
    "memoize": "创建一个会缓存 func 结果的函数。 如果提供了 resolver ，就用 resolver 的返回值作为 key 缓存函数的结果。 默认情况下用第一个参数作为缓存的 key。 func 在调用时 this 会绑定在缓存函数上。注意: 缓存会暴露在缓存函数的 cache 上。 它是可以定制的，只要替换了 _.memoize.Cache 构造函数，或实现了Map 的 delete, get, has, 和 set方法。",
    "flip": "创建一个函数，调用func时候接收翻转的参数。",
    "delay": "延迟 wait 毫秒后调用 func。 调用时，任何附加的参数会传给func。",
    "defer": "推迟调用func，直到当前堆栈清理完毕。 调用时，任何附加的参数会传给func。",
    "debounce": "创建一个 debounced（防抖动）函数，该函数会从上一次被调用后，延迟 wait 毫秒后调用 func 方法。 debounced（防抖动）函数提供一个 cancel 方法取消延迟的函数调用以及 flush 方法立即调用。 可以提供一个 options（选项） 对象决定如何调用 func 方法，options.leading 与|或 options.trailing 决定延迟前后如何触发（注：是 先调用后等待 还是 先等待后调用）。 func 调用时会传入最后一次提供给 debounced（防抖动）函数 的参数。 后续调用的 debounced（防抖动）函数返回是最后一次 func 调用的结果。注意: 如果 leading 和 trailing 选项为 true, 则 func 允许 trailing 方式调用的条件为: 在 wait 期间多次调用防抖方法。 如果 wait 为 0 并且 leading 为 false, func调用将被推迟到下一个点，类似setTimeout为0的超时。 SeeDavid Corbacho's articlefor details over the differences between_.debounce and_.throttle.",
    "curryRight": "这个方法类似_.curry。 除了它接受参数的方式用_.partialRight 代替了_.partial。_.curryRight.placeholder值，默认是以 _ 作为附加部分参数的占位符。Note: 这个方法不会设置 curried 函数的 \"length\" 属性。",
    "curry": "创建一个函数，该函数接收 func 的参数，要么调用func返回的结果，如果 func 所需参数已经提供，则直接返回 func 所执行的结果。或返回一个函数，接受余下的func 参数的函数，可以使用 func.length 强制需要累积的参数个数。_.curry.placeholder值，默认是以 _ 作为附加部分参数的占位符。Note: 这个方法不会设置 curried 函数的 \"length\" 属性。",
    "bindKey": "创建一个函数,在object[key]上通过接收partials附加参数，调用这个方法。 这个方法与_.bind 的不同之处在于允许重新定义绑定函数即使它还不存在。 浏览Peter Michaux's article 了解更多详情。_.bind.placeholder值，默认是以 _ 作为附加部分参数的占位符。",
    "bind": "创建一个调用func的函数，thisArg绑定func函数中的 this (注：this的上下文为thisArg) ，并且func函数会接收partials附加参数。_.bind.placeholder值，默认是以 _ 作为附加部分参数的占位符。注意: 不同于原生的 Function#bind，这个方法不会设置绑定函数的 \"length\" 属性。",
    "before": "创建一个调用func的函数，通过this绑定和创建函数的参数调用func，调用次数不超过 n 次。 之后再调用这个函数，将返回一次最后调用func的结果。",
    "ary": "创建一个调用func的函数。调用func时最多接受 n个参数，忽略多出的参数。",
    "after": "_.before的反向函数;此方法创建一个函数，当他被调用n或更多次之后将马上触发func 。",
    "sortBy": "创建一个元素数组。 以 iteratee 处理的结果升序排序。 这个方法执行稳定排序，也就是说相同元素会保持原始排序。 iteratees 调用1个参数： (value)。",
    "some": "通过 predicate（断言函数） 检查collection（集合）中的元素是否存在 任意 truthy（真值）的元素，一旦 predicate（断言函数） 返回 truthy（真值），遍历就停止。 predicate 调用3个参数：(value, index|key, collection)。",
    "size": "返回collection（集合）的长度，如果集合是类数组或字符串，返回其 length ；如果集合是对象，返回其可枚举属性的个数。",
    "shuffle": "创建一个被打乱值的集合。 使用Fisher-Yates shuffle 版本。",
    "sampleSize": "从collection（集合）中获得 n 个随机元素。",
    "sample": "从collection（集合）中获得一个随机元素。",
    "reject": "_.filter的反向方法;此方法 返回 predicate（断言函数） 不 返回 truthy（真值）的collection（集合）元素（注释：非真）。",
    "reduceRight": "这个方法类似_.reduce ，除了它是从右到左遍历collection（集合）中的元素的。",
    "reduce": "压缩 collection（集合）为一个值，通过 iteratee（迭代函数）遍历 collection（集合）中的每个元素，每次返回的值会作为下一次迭代使用(注：作为iteratee（迭代函数）的第一个参数使用)。 如果没有提供 accumulator，则 collection（集合）中的第一个元素作为初始值。(注：accumulator参数在第一次迭代的时候作为iteratee（迭代函数）第一个参数使用。) iteratee 调用4个参数：(accumulator, value, index|key, collection). lodash 中有许多方法是防止作为其他方法的迭代函数（注：即不能作为iteratee参数传递给其他方法），例如：_.reduce,_.reduceRight, 和_.transform。 受保护的方法有（注：即这些方法不能使用_.reduce,_.reduceRight, 和_.transform作为 iteratee 迭代函数参数）：",
    "partition": "创建一个分成两组的元素数组，第一组包含predicate（断言函数）返回为 truthy（真值）的元素，第二组包含predicate（断言函数）返回为 falsey（假值）的元素。predicate 调用1个参数：(value)。",
    "orderBy": "此方法类似于_.sortBy，除了它允许指定 iteratee（迭代函数）结果如何排序。 如果没指定 orders（排序），所有值以升序排序。 否则，指定为\"desc\" 降序，或者指定为 \"asc\" 升序，排序对应值。",
    "map": "创建一个数组， value（值） 是 iteratee（迭代函数）遍历 collection（集合）中的每个元素后返回的结果。 iteratee（迭代函数）调用3个参数： (value, index|key, collection). lodash 中有许多方法是防止作为其他方法的迭代函数（注：即不能作为iteratee参数传递给其他方法），例如：_.every,_.filter,_.map,_.mapValues,_.reject, 和_.some。 受保护的方法有（注：即这些方法不能使用_.every,_.filter,_.map,_.mapValues,_.reject, 和_.some作为 iteratee 迭代函数参数） ：ary, chunk, curry, curryRight, drop, dropRight, every,fill, invert, parseInt, random, range, rangeRight, repeat,sampleSize, slice, some, sortBy, split, take, takeRight,template, trim, trimEnd, trimStart, and words",
    "keyBy": "创建一个对象组成， key（键） 是 collection（集合）中的每个元素经过 iteratee（迭代函数） 处理后返回的结果。 每个 key（键）对应的值是生成key（键）的最后一个元素。iteratee（迭代函数）调用1个参数：(value)。",
    "invokeMap": "调用path（路径）上的方法处理 collection(集合)中的每个元素，返回一个数组，包含每次调用方法得到的结果。任何附加的参数提供给每个被调用的方法。如果methodName（方法名）是一个函数，每次调用函数时，内部的 this 指向集合中的每个元素。",
    "includes": "检查 value(值) 是否在 collection(集合) 中。如果 collection(集合)是一个字符串，那么检查 value（值，子字符串） 是否在字符串中， 否则使用SameValueZero 做等值比较。 如果指定 fromIndex 是负数，那么从 collection(集合) 的结尾开始检索。",
    "groupBy": "创建一个对象，key 是 iteratee 遍历 collection(集合) 中的每个元素返回的结果。 分组值的顺序是由他们出现在 collection(集合) 中的顺序确定的。每个键对应的值负责生成 key 的元素组成的数组。iteratee 调用 1 个参数： (value)。",
    "forEachRight": "这个方法类似_.forEach，不同之处在于，_.forEachRight 是从右到左遍历集合中每一个元素的。",
    "forEach": "调用 iteratee 遍历 collection(集合) 中的每个元素， iteratee 调用3个参数： (value, index|key, collection)。 如果迭代函数（iteratee）显式的返回 false ，迭代会提前退出。注意: 与其他\"集合\"方法一样，类似于数组，对象的 \"length\" 属性也会被遍历。想避免这种情况，可以用_.forIn 或者_.forOwn 代替。",
    "flatMapDepth": "该方法类似_.flatMap，不同之处在于，_.flatMapDepth 会根据指定的 depth（递归深度）继续扁平化递归映射结果。",
    "flatMapDeep": "这个方法类似_.flatMap 不同之处在于，_.flatMapDeep 会继续扁平化递归映射的结果。",
    "flatMap": "创建一个扁平化（注：同阶数组）的数组，这个数组的值来自collection（集合）中的每一个值经过 iteratee（迭代函数） 处理后返回的结果，并且扁平化合并。 iteratee 调用三个参数： (value, index|key, collection)。",
    "findLast": "这个方法类似_.find ，不同之处在于，_.findLast是从右至左遍历collection （集合）元素的。",
    "find": "遍历 collection（集合）元素，返回 predicate（断言函数）第一个返回真值的第一个元素。predicate（断言函数）调用3个参数： (value, index|key, collection)。",
    "filter": "遍历 collection（集合）元素，返回 predicate（断言函数）返回真值 的所有元素的数组。 predicate（断言函数）调用三个参数：(value, index|key, collection)。Note: Unlike_.remove, this method returns a new array.",
    "every": "通过 predicate（断言函数） 检查 collection（集合）中的 所有 元素是否都返回真值。一旦 predicate（断言函数） 返回假值，迭代就马上停止。predicate（断言函数）调用三个参数： (value, index|key, collection)。注意: 这个方法对于对于空集合返回 true，因为空集合的任何元素都是 true 。",
    "countBy": "创建一个组成对象，key（键）是经过 iteratee（迭代函数） 执行处理collection中每个元素后返回的结果，每个key（键）对应的值是 iteratee（迭代函数）返回该key（键）的次数（注：迭代次数）。 iteratee 调用一个参数：(value)。",
    "zipWith": "这个方法类似于_.zip，不同之处在于它接受一个 iteratee（迭代函数），来 指定分组的值应该如何被组合。 该iteratee调用每个组的元素： (...group).",
    "zipObjectDeep": "这个方法类似_.zipObject，除了它支持属性路径。",
    "zipObject": "这个方法类似_.fromPairs，除了它接受2个数组，第一个数组中的值作为属性标识符（属性名），第二个数组中的值作为相应的属性值。",
    "zip": "创建一个分组元素的数组，数组的第一个元素包含所有给定数组的第一个元素，数组的第二个元素包含所有给定数组的第二个元素，以此类推。",
    "xorWith": "该方法是像_.xor，除了它接受一个 comparator ，以调用比较数组的元素。 comparator 调用2个参数：(arrVal, othVal).",
    "xorBy": "这个方法类似_.xor ，除了它接受 iteratee（迭代器），这个迭代器 调用每一个 arrays（数组）的每一个值，以生成比较的新值。iteratee 调用一个参数：(value).",
    "xor": "创建一个给定数组唯一值的数组，使用symmetric difference做等值比较。返回值的顺序取决于他们数组的出现顺序。",
    "without": "创建一个剔除所有给定值的新数组，剔除值的时候，使用SameValueZero做相等比较。注意: 不像_.pull, 这个方法会返回一个新数组。",
    "unzipWith": "此方法类似于_.unzip，除了它接受一个iteratee指定重组值应该如何被组合。iteratee 调用时会传入每个分组的值： (...group)。",
    "unzip": "这个方法类似于_.zip，除了它接收分组元素的数组，并且创建一个数组，分组元素到打包前的结构。（：返回数组的第一个元素包含所有的输入数组的第一元素，第一个元素包含了所有的输入数组的第二元素，依此类推。）",
    "uniqWith": "这个方法类似_.uniq， 除了它接受一个 comparator 调用比较arrays数组的每一个元素。 comparator 调用时会传入2个参数： (arrVal, othVal)。",
    "uniqBy": "这个方法类似_.uniq ，除了它接受一个 iteratee （迭代函数），调用每一个数组（array）的每个元素以产生唯一性计算的标准。iteratee 调用时会传入一个参数：(value)。",
    "uniq": "创建一个去重后的array数组副本。使用了SameValueZero 做等值比较。只有第一次出现的元素才会被保留。",
    "unionWith": "这个方法类似_.union， 除了它接受一个 comparator 调用比较arrays数组的每一个元素。 comparator 调用时会传入2个参数： (arrVal, othVal)。",
    "unionBy": "这个方法类似_.union ，除了它接受一个 iteratee （迭代函数），调用每一个数组（array）的每个元素以产生唯一性计算的标准。iteratee 会传入一个参数：(value)。",
    "union": "创建一个按顺序排列的唯一值的数组。所有给定数组的元素值使用SameValueZero做等值比较。（注： arrays（数组）的并集，按顺序返回，返回数组的元素是唯一的）",
    "takeWhile": "从array数组的起始元素开始提取元素，，直到 predicate 返回假值。predicate 会传入三个参数： (value, index, array)。",
    "takeRightWhile": "从array数组的最后一个元素开始提取元素，直到 predicate 返回假值。predicate 会传入三个参数： (value, index, array)。",
    "takeRight": "创建一个数组切片，从array数组的最后一个元素开始提取n个元素。",
    "take": "创建一个数组切片，从array数组的起始元素开始提取n个元素。",
    "tail": "获取除了array数组第一个元素以外的全部元素。",
    "sortedUniqBy": "这个方法类似_.uniqBy，除了它会优化排序数组。",
    "sortedUniq": "这个方法类似_.uniq，除了它会优化排序数组。",
    "sortedLastIndexOf": "这个方法类似_.lastIndexOf，除了它是在已经排序的数组array上执行二进制检索。",
    "sortedLastIndexBy": "这个方法类似_.sortedLastIndex ，除了它接受一个 iteratee （迭代函数），调用每一个数组（array）元素，返回结果和value 值比较来计算排序。iteratee 会传入一个参数：(value)。",
    "sortedLastIndex": "此方法类似于_.sortedIndex，除了 它返回 value值 在 array 中尽可能大的索引位置（index）。",
    "sortedIndexOf": "这个方法类似_.indexOf，除了它是在已经排序的数组array上执行二进制检索。",
    "sortedIndexBy": "这个方法类似_.sortedIndex ，除了它接受一个 iteratee （迭代函数），调用每一个数组（array）元素，返回结果和value 值比较来计算排序。iteratee 会传入一个参数：(value)。",
    "sortedIndex": "使用二进制的方式检索来决定 value值 应该插入到数组中 尽可能小的索引位置，以保证array的排序。",
    "slice": "裁剪数组array，从 start 位置开始到end结束，但不包括 end 本身的位置。Note: 这个方法用于代替Array#slice 来确保数组正确返回。",
    "remove": "移除数组中predicate（断言）返回为真值的所有元素，并返回移除元素组成的数组。predicate（断言） 会传入3个参数： (value, index, array)。Note: 和_.filter不同, 这个方法会改变数组 array。使用_.pull来根据提供的value值从数组中移除元素。",
    "pullAt": "根据索引 indexes，移除array中对应的元素，并返回被移除元素的数组。Note: 和_.at不同, 这个方法会改变数组 array。",
    "pullAllWith": "这个方法类似于_.pullAll，区别是这个方法接受 comparator 调用array中的元素和values比较。comparator 会传入两个参数：(arrVal, othVal)。注意: 和_.differenceWith 不同, 这个方法会改变数组 array。",
    "pullAllBy": "这个方法类似于_.pullAll ，区别是这个方法接受一个 iteratee（迭代函数） 调用 array 和 values的每个值以产生一个值，通过产生的值进行了比较。iteratee 会传入一个参数： (value)。Note: 不同于_.differenceBy, 这个方法会改变数组 array。",
    "pullAll": "这个方法类似_.pull，区别是这个方法接收一个要移除值的数组。Note: 不同于_.difference, 这个方法会改变数组 array。",
    "pull": "移除数组array中所有和给定值相等的元素，使用SameValueZero 进行全等比较。注意： 和_.without 方法不同，这个方法会改变数组。使用_.remove 从一个数组中移除元素。",
    "nth": "获取array数组的第n个元素。如果n为负数，则返回从数组结尾开始的第n个元素。",
    "lastIndexOf": "这个方法类似_.indexOf ，区别是它是从右到左遍历array的元素。",
    "last": "获取array中的最后一个元素。",
    "join": "将 array 中的所有元素转换为由 separator 分隔的字符串。",
    "intersectionWith": "这个方法类似_.intersection，区别是它接受一个 comparator 调用比较arrays中的元素。结果值是从第一数组中选择。comparator 会传入两个参数：(arrVal, othVal)。",
    "intersectionBy": "这个方法类似_.intersection，区别是它接受一个 iteratee 调用每一个arrays的每个值以产生一个值，通过产生的值进行了比较。结果值是从第一数组中选择。iteratee 会传入一个参数：(value)。",
    "intersection": "创建唯一值的数组，这个数组包含所有给定数组都包含的元素，使用SameValueZero进行相等性比较。（注：可以理解为给定数组的交集）",
    "initial": "获取数组array中除了最后一个元素之外的所有元素（注：去除数组array中的最后一个元素）。",
    "indexOf": "使用SameValueZero 等值比较，返回首次 value 在数组array中被找到的 索引值， 如果 fromIndex 为负值，将从数组array尾端索引进行匹配。",
    "head": "获取数组 array 的第一个元素。",
    "fromPairs": "与_.toPairs正好相反；这个方法返回一个由键值对pairs构成的对象。",
    "flattenDepth": "根据 depth 递归减少 array 的嵌套层级",
    "flattenDeep": "将array递归为一维数组。",
    "flatten": "减少一级array嵌套深度。",
    "findLastIndex": "这个方式类似_.findIndex， 区别是它是从右到左的迭代集合array中的元素。",
    "findIndex": "该方法类似_.find，区别是该方法返回第一个通过 predicate 判断为真值的元素的索引值（index），而不是元素本身。",
    "fill": "使用 value 值来填充（替换） array，从start位置开始, 到end位置结束（但不包含end位置）。",
    "dropWhile": "创建一个切片数组，去除array中从起点开始到 predicate 返回假值结束部分。predicate 会传入3个参数： (value, index, array)。",
    "dropRightWhile": "创建一个切片数组，去除array中从 predicate 返回假值开始到尾部的部分。predicate 会传入3个参数： (value, index, array)。",
    "dropRight": "创建一个切片数组，去除array尾部的n个元素。（n默认值为1。）",
    "drop": "创建一个切片数组，去除array前面的n个元素。（n默认值为1。）",
    "differenceWith": "这个方法类似_.difference ，除了它接受一个 comparator （注：比较器），它调用比较array，values中的元素。 结果值是从第一数组中选择。comparator 调用参数有两个：(arrVal, othVal)。Note: 不像_.pullAllWith, 这个方法会返回一个新数组。",
    "differenceBy": "这个方法类似_.difference ，除了它接受一个 iteratee （注：迭代器）， 调用array 和 values 中的每个元素以产生比较的标准。 结果值是从第一数组中选择。iteratee 会调用一个参数：(value)。（注：首先使用迭代器分别迭代array 和 values中的每个元素，返回的值作为比较值）。Note: 不像_.pullAllBy，这个方法会返回一个新数组。",
    "difference": "创建一个具有唯一array值的数组，每个值不包含在其他给定的数组中。（注：即创建一个新数组，这个数组中的值，为第一个数字（array 参数）排除了给定数组中的值。）该方法使用SameValueZero做相等比较。结果值的顺序是由第一个数组中的顺序确定。注意: 不像_.pullAll，这个方法会返回一个新数组。",
    "concat": "创建一个新数组，将array与任何数组 或 值连接在一起。",
    "compact": "创建一个新数组，包含原数组中所有的非假值元素。例如false, null,0, \"\", undefined, 和 NaN 都是被认为是“假值”。",
    "chunk": "将数组（array）拆分成多个 size 长度的区块，并将这些区块组成一个新数组。 如果array 无法被分割成全部等长的区块，那么最后剩余的元素将组成一个区块。"
}